# 生ポインタ

Rustは標準ライブラリにスマートポインタ(訳注: スコープの終端で参照先のリソースを開放してくれるポインタ、C++の概念)の型を幾つか用意していますが、加えて2つ特別な型があります。Rustの安全性の多くはコンパイル時のチェックから来ていますが、生ポインタや[unsafe](https://doc.rust-lang.org/stable/book/unsafe.html)を使用するとそれらのような保証が得られません。

`*const T`と`*mut T`はRustにおいて'生ポインタ'と呼ばれます。時々、特定の種類のライブラリを書く時に、あなたは幾つかの理由でRustが行う安全性の保証を避けなければならないことがあります。今回のケースでは、ユーザに安全なインターフェースを提供するライブラリを実装する際に生ポインタを使用できます。例えば、ポインタは * を使うことでエイリアスとして振る舞うこともできるので、所有権を共有する型や、スレッドセーフな共有メモリ型でさえも実装することができます。(`Rc<T>`と`Arc<T>`型は完全にRustのみで実装されています)


以下は覚えておくべき生ポインタとその他のポインタ型との違いです。

- 正しいメモリを指しているか保証されず、nullでないかどうかも保証されない(`Box`と`&`では保証される)
- 自動的な後処理は一切行われず、`Box`とは異なり、手動によるリソースの管理が必要
- plain-old-data型(訳注: メモリ上で連続して表現されるデータ、C言語のデータと互換を持つ構造とも)であるため、所有権を移譲できず、従ってRustのコンパイラはuse-after-free(訳注: 知らなければggr推奨です)のような脆弱性を防ぐことができない
- 生存期間の機能が欠如しているため、`&`と異なり、コンパイラはダングリングポインタを推論できない
- `*const T`を直接介した変更は拒むが、それ以外のエイリアシングや可変性に関する保証はない

# 基本

完全に安全な生ポインタを作成してみます。

```rust
let x = 5;
let raw = &x as *const i32;

let mut y = 10;
let raw_mut = &mut y as *mut i32;
```

しかしながら1つ目は参照することができないため、以下は動作しません。

```rust,ignore
let x = 5;
let raw = &x as *const i32;

println!("raw points at {}", *raw);
```

このようなエラーが発生します。

```text
error: dereference of unsafe pointer requires unsafe function or block [E0133]
     println!("raw points at{}", *raw);
                                 ^~~~
```

あなたが生ポインタを参照するとき、間違っている所を指していないという責任を負わなければなりません。ですので、あなたは`unsafe`を使う必要があります。

```rust
let x = 5;
let raw = &x as *const i32;

let points_at = unsafe { *raw };

println!("raw points at {}", points_at);
```
生ポインタの操作に関する詳細は、[APIドキュメント](https://doc.rust-lang.org/stable/std/primitive.pointer.html)を参照してください。

# FFI

生ポインタはFFI関係で役立ちます。Rustの`*const T`と`*mut T`はそれぞれCの`const T*`と`*mut T`に似ているからです。これについての詳細は、[FFIの章](https://doc.rust-lang.org/stable/book/ffi.html)を参照してください。

# 参照と生ポインタ

実行時において、生ポインタと参照がデータの同じ部分を指すというのは同一の表現です。実際、unsafeを使っていない範囲においては`&T`は暗黙的に`*const T`へキャスト可能であり、`mut`の場合も同様です。(`value as *const T`及び`value as *mut T`へ明示的にキャストすることも可能です)

反対に、`*const`から`&`へキャストするのは安全ではありません。`&T`は常に有効であるため、最低でも`*const T`は型`T`の有効な実体を指さなければなりません。その上、ポインタは参照のエイリアシングと可変性の規則も満たす必要があります。コンパイラは全ての参照についてこれらのプロパティが真であることを前提としているため、その生成方法によらず、生ポインタからのあらゆるキャストもまた真であることを断言できなければなりません。プログラマがこのことを保証*しなければならない*のです。

おすすめの変換の方法は以下のとおりです。

```rust
let i: u32 = 1;

// 明示的キャスト
let p_imm: *const u32 = &i as *const u32;
let mut m: u32 = 2;

// 暗黙的変換
let p_mut: *mut u32 = &mut m;

unsafe {
    let ref_imm: &u32 = &*p_imm;
    let ref_mut: &mut u32 = &mut *p_mut;
}
```
`&*x`によって参照するスタイルは`transmute`を用いるより好ましいです。後者は必要以上に強力ですし、より用途が限定されている操作の方が間違いにくいでしょう。例えば、前者の方法は`x`がポインタである必要があります。(`transmute`は異なります)
