% Rust プログラミング言語

ようこそ！
この本は、 [Rust プログラミング言語][rust] について説明します。
Rust は、安全性、速度、並行処理という
3 つの目的に焦点を当てたシステムプログラミング言語です。
この言語はガーベジコレクタを持つことなくそれらの目的を維持します。
そして、他の言語が得意としないいくつかのユースケース
(他言語への埋め込み、空間・時間が規定されたプログラム、
デバイスドライバやオペレーティングシステムのような低水準コードの記述)
に役立つ言語になっています。
実行時オーバヘッドのない幾つかのコンパイル時安全検査があることで、
そのスペースを目標としている現在の言語をより良いものにします。
またその一方で、全てのデータ競合を取り除きます。
たとえこれらの抽象化の一部が高級言語のもののように感じられるとしても、
Rust は「ゼロコストの抽象化」を成し遂げることを目指しています。
それでもなお、 Rust は低水準言語がするような正確な制御を可能としています。

[rust]: http://rust-lang.org

『Rust プログラミング言語』は 7 つの節に分かれています。
本序論がその 1 つ目です。 その後は、次のようになっています。

* [はじめに][gs] - Rust 開発のためのコンピュータのセットアップ
* [Rust の学習][lr] - 小規模プロジェクトを通じた Rust プログラミング
* [Effective Rust][er] - 優れた Rust コードを書くための高度な概念
* [構文と意味論][ss] - Rust を小さな塊へ分解
* [Nightly Rust][nr] - 安定版ビルドにはまだない最先端の機能
* [用語集][gl] - 本で使われる用語のリファレンス
* [学術研究][ar] - Rust に影響を与えた文献

[gs]: getting-started.html
[lr]: learn-rust.html
[er]: effective-rust.html
[ss]: syntax-and-semantics.html
[nr]: nightly-rust.html
[gl]: glossary.html
[ar]: academic-research.html

本序論を読んだ後、
あなたは好みに従って「Rust の学習」または「構文と意味論」
のどちらかに飛び込みたくなるでしょう。
もしプロジェクトに飛び込みたいなら「Rust の学習」を、
小さくはじめるのを好むなら「構文と意味論」を読み、
次へ進む前に完全に一つの概念を学びましょう。
おびただしいクロスリンキングが一緒にこれらのパートをつなぎます。

### 貢献

この本のソースファイルは、次の Github で見つかります。
[github.com/tut-cc/rust-doc-ja/tree/stable/src/doc/trpl](https://github.com/tut-cc/rust-doc-ja/tree/stable/src/doc/trpl)

## Rust の短い序論

Rust に興味があるかもしれませんか？
その強さを見せるために、いくつかのコード例を調べてみましょう。

Rust をユニークにする主な概念は、「所有 (ownership)」 と呼ばれるものです。
次の例を考えてみましょう。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];
}
```

このプログラムは `x` と名付けられた [変数束縛][var] を作成しています。
束縛している値は、標準ライブラリで定義された [マクロ][macro] を通して作成された
`Vec<T>` 、ベクトルです。
このマクロは `vec` と呼ばれており、マクロは `!` をつけることで呼び出されます。
これは、 Rust の一般原則、 make things explicit (物事は明示せよ) に従っています。
マクロは関数呼び出しよりもかなり複雑なことをすることができるので、視覚的に明瞭にします。
`!` はパージングも助け、より容易に書けるようにします。そしてまたそれは重要です。

`mut` を使った理由は、 `x` をミュータブルにするためです。
デフォルトで Rust は、束縛はイミュータブルです。

ここで型注釈を必要としなかったことにも注意する価値があります。
Rust が静的に型付けられる間、明示的に型を注釈する必要がありませんでした。
静的型付けの力と、型注釈をつける冗長さのバランスをとるために、 Rust には型推論があります。

Rust はヒープ割り当てよりもスタック割り当てを好みます。`x` はスタックに直接配置されます。
しかし、 `Vec<T>` 型はヒープの領域をベクトルの要素に割り当てます。
もしこれらの区別をよく知らないならば、
今はこれを無視することも、 [「スタックとヒープ」][heap] を確認することもできます。
システムプログラミング言語として、
Rust はメモリがどう割り当てられるのかを制御する能力をあなたに与えます。
しかし、Rust を始めたばかりのときには、それはあまり大したことではありません。

[var]: variable-bindings.html
[macro]: macros.html
[heap]: the-stack-and-the-heap.html

我々は先ほど、「所有 (ownership)」が Rust の鍵となる新しい概念だと説明しました。
Rust 用語では、 `x` はベクトルを 所有 (`own`) する、と言われています。
これは、 `x` がスコープから出るとき、そのベクトルのメモリが解放されることを意味しています。
ガーベジコレクタのようなメカニズムによるものではなく、
これは Rust コンパイラにより決定論的に行われます。
言い換えると Rust では、
あなたは `malloc` や `free` のような命令を自分自身で呼び出すことは出来ません。
コンパイラが静的に、いつメモリを割り当て解放する必要があるかを決定し、
それらの命令を挿入します。
誤るのは人間だからであり、コンパイラは絶対に忘れません。

先ほどの例にもう一つ、行を追加しましょう。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = &x[0];
}
```

もう一つの束縛、 `y` を導入しました。
このケースでは、 `y` はベクトルの先頭要素への参照です。
Rust の参照は他言語のポインタによく似ていますが、
付加的なコンパイル時安全チェックが行われます。
それを所有するのではなくそれらが指すものを [「借りること (borrowing)」][borrowing] によって、
参照は所有システム (ownership system) と相互作用します。
違いは、参照がスコープから出たときその先のメモリを解放しないことです。
もし解放してしまったら、私たちはメモリ解放を二回行うことになります。
そしてそれはいけないことです！

[borrowing]: references-and-borrowing.html

三行目を追加しましょう。
無害に見えますが、これはコンパイルエラーを引き起こします。

```rust,ignore
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = &x[0];

    x.push("foo");
}
```

`push` はもう一つの要素をベクトルの末尾に追加するメソッドです。
このプログラムは、コンパイルしようとするとエラーを吐きます。

```text
error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push("foo");
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
```

うひゃあ！
Rust コンパイラはときどき極めて詳細なエラーを吐きます。これはそんなときのうちの一つです。
エラーが説明するように、
束縛をミュータブルにしたとしてもまだ `push` を呼ぶことはできません。
これは、ベクトルの要素への参照 `y` を既に持っているからです。
我々がもう一つの参照を無効にするかもしれないので、
その参照が存在している間、何かを変更するのは危険なのです。
この特定のケースでは、ベクトルを作ったとき、 
3 つの要素のための領域を確保するだけだったかもしれません。
4 番目の要素を加えることは、それら全ての要素のために、
新たにかなりの量のメモリを確保し、古い値をコピーし、
そして内部ポインタをそのメモリへと更新することを意味するでしょう。
それは、ちゃんと問題なく全て動きます。
問題は、 `y` が更新されず、「ダングリングポインタ」を持ってしまうだろうことです。
それはいけないことです。
この場合、 `y` はいかなる使用においてもエラーとなるでしょう。
したがって、コンパイラは我々のためにこれを捉えたのです。

では、どのようにこの問題を解決するのでしょうか？
我々がとることのできるアプローチは 2 つあります。
1 つ目は、参照を使用するのではなく、コピーを作ることです。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = x[0].clone();

    x.push("foo");
}
```

Rust はデフォルトで [ムーブセマンティクス][move] を持っているので、
我々がデータのコピーを作りたいときには `clone()` メソッドを呼びます。
この例では、 `y` はもはや `x` にストアされているベクトルへの参照ではなく、
その先頭要素、 `"Hello"` のコピーです。
参照を持たなくなった今、我々の `push()` はちゃんと問題なく動きます。

[move]: move-semantics.html

参照が本当に欲しいのであれば、他の選択を必要とします。
ベクトルの内容を変更しようとする前に、
参照がスコープ外へ出ることを保証しましょう。

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    {
        let y = &x[0];
    }

    x.push("foo");
}
```

波括弧を付加することにより、内部スコープを作成しました。
`push()` を呼ぶ前に `y` はスコープ外へと出ているので、問題ありません。

所有の概念はダングリングポインタを予防するのみならず、
関連した問題 (イテレータ無効化、並行処理、などなど) の全てについても望ましいものです。
